module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  sig rst;                  // reset signal
  
  //eight_bit_adder eightbitadder;
  
  //rom fulladderROM;
  
  //sixteen_bit_adder sixteenbitadder;
   
   dff store1[16](.clk(clk));
   dff store2[16](.clk(clk));
  counter slowclock(#SIZE(1),#DIV(26), .clk(clk), .rst(rst));
  autotest autotester(.clk(slowclock.value),.rst(rst));
  alu alu_test;
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
    fsm state = {IDLE, STORE1, STORE2, CALCULATE, AUTO, // Manual testing
              TESTADDER1, TESTADDER2, TESTADDER3, // Adder test cases
              TESTBOOL1, TESTBOOL2, TESTBOOL3,   // Boolean test cases
              TESTSHIFT1, TESTSHIFT2, TESTSHIFT3,  // Shifter test cases
              TESTCMP1, TESTCMP2, TESTCMP3,    // Comparator test cases
              PASS, FAIL};  // Other test cases// Other test cases
    
  }
 
  always {
  io_sel = 4hf; // select no digits


    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    usb_tx = usb_rx;        // loop serial port
    
    led = 8h00;             // turn LEDs off
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    
    //eight bit
 // eightbitadder.x = io_dip[0];
//eightbitadder.y = io_dip[1];
//eightbitadder.cin = io_dip[2][0];
//io_led[1] = eightbitadder.s;
//io_led[2][0] = eightbitadder.cout;
    //rom
 //    fulladderROM.address[2] = io_dip[0][2];
	// fulladderROM.address[1] = io_dip[0][1];
	// fulladderROM.address[0] = io_dip[0][0];
 //io_led[2][1] = fulladderROM.value[1];
//	io_led[2][0] = fulladderROM.value[0];
    //16 adder
    
  
   alu_test.alusignal = io_dip[2][5:0];
    alu_test.a=0;
    alu_test.b=0;
     
    case (state.q)
    { state.IDLE:
      if(io_button[0])
        {
        state.d=state.STORE1;
        }
      if(io_button[3])
        {state.d=state.AUTO;
        }
      state.STORE1: 
     io_led[1] = io_dip[1];
    io_led[0] = io_dip[0]; 
     if(io_button[1]){           //if button is pressed, store input a into a d flip flop
      store1.d[15:8] = io_dip[1];
      store1.d[7:0]  = io_dip[0];
      state.d=state.STORE2;      
    }
   if(io_button[4])
      {state.d=state.IDLE;
      }
        
     
    state.STORE2:
    io_led[1] = io_dip[1];
     io_led[0] = io_dip[0];
   if(io_button[2])
    {    store2.d[15:8] = io_dip[1];
          store2.d[7:0]  = io_dip[0];
           
          state.d=state.CALCULATE;      
    }
    if(io_button[4])
        {state.d=state.IDLE;
        }
        
        
    state.CALCULATE:
    alu_test.a = store1.q;
    alu_test.b = store2.q;
    alu_test.alusignal = io_dip[2][5:0];
    io_led[1] = alu_test.out[15:8];
    io_led[0] = alu_test.out[7:0];
    io_led[2][0] = alu_test.zvn[0];
    io_led[2][1] = alu_test.zvn[1];
    io_led[2][2] =alu_test.zvn[2];
    if(io_button[4])
    {state.d = state.IDLE;
     }
      state.AUTO:
    if(io_button[0])
        {
        io_led[1]=autotester.out[15:8];
         io_led[0] = autotester.out[7:0];
        }
    if(io_button[4])
        {
        state.d=state.IDLE;
        }
      
 
 
  
    
    

    
  }
}